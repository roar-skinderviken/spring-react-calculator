<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Favi Icon-->
    <link rel="icon" href="img/logo-no-background.png" type="image/png">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
          crossorigin="anonymous">

    <!-- Font Awesome CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">

    <!-- CSS link -->
    <link rel="stylesheet" href="CSS/esport.css">

    <title>Esport | VICX</title>

</head>
<body>

<!--# include virtual="navbar.html" -->

<main class="content">
    <div class="hero">
        <div class="container">
            <h1><span>Counter Strike Esport</span></h1>
            <p class="lead">These are the live matches</p>
        </div>
    </div>
    <div class="main-container">
        <div class="section" id="running-matches">
            <h1>Running Matches</h1>
        </div>
        <div class="section" id="upcoming-matches">
            <h1>Upcoming Matches</h1>
        </div>
    </div>
</main>

<!--# include virtual="footer.html" -->

<script>
    const fetchAndDisplayMatches = (url, elementId) => {
        fetch(url)
            .then(response => response.json())
            .then(data => {
                const matchesDiv = document.getElementById(elementId);
                matchesDiv.innerHTML = ''; // Clear previous matches

                // Create promises for fetching opponents
                const matchPromises = data.map(match => {
                    const matchId = match.id; // Assuming each match has an ID property
                    return fetch(`https://api.pandascore.co/matches/${matchId}/opponents`, {
                        headers: { accept: 'application/json' }
                    })
                        .then(opponentsResponse => opponentsResponse.json())
                        .then(opponentsData => ({
                            match: match,
                            opponents: opponentsData
                        }));
                });

                // Wait for all opponent fetches to complete
                Promise.all(matchPromises)
                    .then(matchesWithOpponents => {
                        matchesWithOpponents.forEach(({ match, opponents }) => {
                            if (opponents.length >= 2) {
                                const team1 = opponents[0]?.name || 'Team 1';
                                const team2 = opponents[1]?.name || 'Team 2';
                                const matchElement = document.createElement('div');
                                matchElement.className = 'match';
                                matchElement.innerHTML = `
                                <h2>${team1} vs ${team2}</h2>
                                <p>Date: ${new Date(match.begin_at).toLocaleDateString()}</p>
                                <p>Status: ${match.status}</p>
                            `;
                                matchesDiv.appendChild(matchElement);
                            } else {
                                console.error('Not enough opponents for match:', match);
                            }
                        });
                    })
                    .catch(error => console.error('Error fetching opponents:', error));
            })
            .catch(error => console.error('Error fetching data:', error));
    };

    // Call this function for both running and upcoming matches
    fetchAndDisplayMatches(runningMatchesUrl, 'running-matches');
    fetchAndDisplayMatches(upcomingMatchesUrl, 'upcoming-matches');

</script>
</body>
</html>
